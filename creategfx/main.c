/*
Dieses Programm erzeugt für die Grafiken eine zusammengefasste Binärdatei,
die Grafiken in einer Datei enthält. Zur Binärdatei wird eine
entsprechende Headerdatei erzeugt, die die Offsets zu den Einzeldateien enthält.
*/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdbool.h>
#include <stdint.h>

#define SAFE_FREE(x) { if (x != NULL) { free(x); x = NULL; } }

uint8_t *ReadFile(char *pszFilename,uint32_t *puLen);
int CreateTextureLine(char *szHead,char *szFilename,int32_t uIndex);


int main(int argc, char *argv[]) {
    char szHead[1024];
    char szInputfile[64];
    char szOutputfile[64];
    char szHeaderfile[64];
    char szTextureHeaderfile[64];
    char szFilename[512];
    FILE *Readfile = NULL;
    FILE *Writefile = NULL;
    FILE *WriteHeaderfile = NULL;
    FILE *WriteTexturesHeaderfile = NULL;

    struct stat Fileinfo;
    char cSign;
    bool bOK;
    uint32_t I;
    size_t uReadCount;
    uint8_t *pData;
    uint32_t uFileLen;
    uint32_t uOffset;
    int32_t uIndex;

    strcpy(szInputfile,"filelist.txt");
    strcpy(szOutputfile,"gfx.bin");
    strcpy(szHeaderfile,"gfx.h");
    strcpy(szTextureHeaderfile,"textures.h");
    uIndex = 0;
    if (stat(szInputfile,&Fileinfo) == 0) {
        if (Fileinfo.st_size > 0) {
            WriteHeaderfile = fopen(szHeaderfile,"wb");
            WriteTexturesHeaderfile = fopen(szTextureHeaderfile,"wb");
            Writefile = fopen(szOutputfile,"wb");
            Readfile = fopen(szInputfile,"rb");
            if ((Readfile != NULL) && (Writefile != NULL) && (WriteHeaderfile != NULL)) {
                strcpy(szHead,"// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT !\r\n\r\n");
                bOK = (fwrite(szHead,1,strlen(szHead),WriteHeaderfile) == strlen(szHead));
                bOK = (fwrite(szHead,1,strlen(szHead),WriteTexturesHeaderfile) == strlen(szHead));
                strcpy(szHead,"    uint32_t Gfx[] = {\r\n");
                bOK = (fwrite(szHead,1,strlen(szHead),WriteHeaderfile) == strlen(szHead));
                strcpy(szHead,"#ifndef TEXTURES_H_INCLUDED\r\n#define TEXTURES_H_INCLUDED\r\n\r\n");
                bOK = (fwrite(szHead,1,strlen(szHead),WriteTexturesHeaderfile) == strlen(szHead));
                memset(szFilename,0,sizeof(szFilename));
                I = 0;
                uReadCount = 0;
                uOffset = 0;
                do {
                    if (fread(&cSign,1,1,Readfile) == 1) {  // 1 Byte aus Datei lesen
                        uReadCount++;
                        if (cSign == 0x0A) {
                            // Zeichen überlesen
                        } else if (cSign == 0x0D) { // Zeilenende ?
                            szFilename[I] = 0;
                            pData = ReadFile(szFilename,&uFileLen);
                            if (pData != NULL) {
                                printf("Filename: %s     FileLen: %u\r\n",szFilename,uFileLen);
                                bOK = (fwrite(pData,1,uFileLen,Writefile) == uFileLen);
                                if (bOK) {
                                    sprintf(szHead,"        0x%08X,0x%08X,     // %04d - %s\r\n",uOffset,uFileLen,uIndex,szFilename);
                                    bOK = (fwrite(szHead,1,strlen(szHead),WriteHeaderfile) == strlen(szHead));
                                    uOffset = uOffset + uFileLen;
                                    if (CreateTextureLine(szHead,szFilename,uIndex) == 0) {
                                        bOK = (fwrite(szHead,1,strlen(szHead),WriteTexturesHeaderfile) == strlen(szHead));
                                    }
                                    uIndex++;
                                } else {
                                    printf("write error\r\n");
                                }
                                SAFE_FREE(pData);
                            } else {
                                printf("can not open file: %s\r\n",szFilename);
                                bOK =  false;
                            }
                            I = 0; // Für nächsten Filenamen zurück setzen
                            memset(szFilename,0,sizeof(szFilename));
                        } else {
                            szFilename[I] = cSign;
                            I++;
                        }
                    } else {
                        printf("read error\r\n");
                        bOK = false;
                    }
                } while ((uReadCount < Fileinfo.st_size) && bOK);
                if (bOK) {
                    if (I > 0) {    // Letzte Zeile hatte kein 0x0D
                        pData = ReadFile(szFilename,&uFileLen);
                        if (pData != NULL) {
                            printf("Filename: %s     FileLen: %u\r\n",szFilename,uFileLen);
                            bOK = (fwrite(pData,1,uFileLen,Writefile) == uFileLen);
                            if (bOK) {
                                sprintf(szHead,"        0x%08X,0x%08X,     // %04d - %s\r\n",uOffset,uFileLen,uIndex,szFilename);
                                bOK = (fwrite(szHead,1,strlen(szHead),WriteHeaderfile) == strlen(szHead));
                                uOffset = uOffset + uFileLen;
                                uIndex++;
                            } else {
                                printf("write error\r\n");
                            }
                            SAFE_FREE(pData);
                        } else {
                            printf("malloc error\r\n");
                            bOK =  false;
                        }
                    }
                    sprintf(szHead,"        0x%08X,0x%08X      // Endekennung\r\n",0xFFFFFFFF,0xFFFFFFFF);
                    bOK = (fwrite(szHead,1,strlen(szHead),WriteHeaderfile) == strlen(szHead));
                    strcpy(szHead, "        };\r\n");
                    bOK = (fwrite(szHead,1,strlen(szHead),WriteHeaderfile) == strlen(szHead));
                    sprintf(szHead,"\r\n\r\n#endif // TEXTURES_H_INCLUDED\r\n");
                    bOK = (fwrite(szHead,1,strlen(szHead),WriteTexturesHeaderfile) == strlen(szHead));
                }
            } else {
                printf("can not open file(s)\r\n");
            }
        } else {
            printf("bad filesize: %d\r\n",(int)Fileinfo.st_size);
        }
    } else {
        printf("stat error, file: %s\r\n",szInputfile);
    }
    if (Readfile != NULL) {
        fclose(Readfile);
    }
    if (Writefile != NULL) {
        fclose(Writefile);
    }
    if (WriteHeaderfile != NULL) {
        fclose(WriteHeaderfile);
    }
    if (WriteTexturesHeaderfile != NULL) {
        fclose(WriteTexturesHeaderfile);
    }
    return 0;
}


/*----------------------------------------------------------------------------
Name:           ReadFile
------------------------------------------------------------------------------
Beschreibung: Liest Daten aus einer Datei und alloziert hierfür Speicher, der
              außerhalb dieser Funktion wieder freigegeben werden muss.
Parameter
      Eingang: pszFilename, char *, Zeiger auf Dateinamen (komplette Pfadangabe)
      Ausgang: puLen, uint32_t *, Anzahl Bytes, die eingelesen bzw. alloziert wurden.
Rückgabewert:  uint8_t *, NULL = Fehler, sonst Zeiger auf allozierten Speicher mit Daten.
Seiteneffekte:
------------------------------------------------------------------------------*/
uint8_t *ReadFile(char *pszFilename,uint32_t *puLen)
{
    uint8_t *pRet = NULL;
    FILE *Readfile = NULL;
    struct stat Fileinfo;

    if ( (pszFilename != NULL) && (puLen != NULL) ) {
        if (stat(pszFilename,&Fileinfo) == 0) {
            if (Fileinfo.st_size > 0) {
                Readfile = fopen(pszFilename,"rb");
                if (Readfile != NULL) {
                    pRet = (uint8_t*)malloc(Fileinfo.st_size);
                    if (pRet != NULL) {
                        if (fread(pRet,1,Fileinfo.st_size,Readfile) == (size_t)Fileinfo.st_size) { // Datei lesen
                            *puLen = Fileinfo.st_size;
                        } else {
                            printf("%s: read error, freeing memory\r\n",__FUNCTION__);
                            SAFE_FREE(pRet);
                        }
                    } else {
                        printf("%s: can not allocate memory for filesize: %ld\r\n",__FUNCTION__,Fileinfo.st_size);
                    }
                } else {
                    printf("%s: can not open file: %s\r\n",__FUNCTION__,pszFilename);
                }
            } else {
                printf("%s: file is empty\r\n",__FUNCTION__);
            }
        } else {
            printf("%s: stat() failed, filename: %s\r\n",__FUNCTION__,pszFilename);
        }
    } else {
        printf("%s: bad parameter\r\n",__FUNCTION__);
    }
    if (Readfile != NULL) {
        fclose(Readfile);
    }
    return pRet;
}


/*----------------------------------------------------------------------------
Name:           CreateTextureLine
------------------------------------------------------------------------------
Beschreibung: Erzeugt für den Header "textures.h" eine #define-Zeile.

Parameter
      Eingang: szFilename, char *, Zeiger auf Dateinamen der BMP-Grafik
               uIndex, int32_t, Index der Texture
      Ausgang: szHead, chart *, Zeiger auf fertige #define-Zeile
Rückgabewert:  int, 0 = Alles ok, sonst Fehler
Seiteneffekte:
------------------------------------------------------------------------------*/
int CreateTextureLine(char *szHead,char *szFilename,int32_t uIndex) {
    int nError = -1;
    int nSpaces;
    size_t len;
    int I;
    char szNum[32];

    if ((szHead != NULL) && (szFilename != NULL)) {
        len = strlen(szFilename);
        if (len > 4) {   // mindestens Dateiextension ".bmp" und ein Zeichen
            for (I = 0; I < len; I++) {
                szFilename[I] = toupper(szFilename[I]);
            }
            if (strcmp(szFilename + len - 4,".BMP") == 0) {
                szFilename[len - 4] = 0;        // ".BMP" abschneiden
                sprintf(szHead,"#define TEX_%s",szFilename);
                nSpaces = 80 - len;
                while (nSpaces > 0) {
                    strcat(szHead," ");
                    nSpaces--;
                }
                sprintf(szNum,"%d\r\n",uIndex);
                strcat(szHead,szNum);
                nError = 0;
            } else {
                printf("%s: no bmp file: %s\r\n",__FUNCTION__,szFilename);
            }
        } else {
            printf("%s: fileame too short\r\n",__FUNCTION__);
        }


    } else {
        printf("%s: bad pointer\r\n",__FUNCTION__);
    }
    return nError;
}





