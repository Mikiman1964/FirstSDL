/*
Dieses Programm erzeugt für die Game-Musik und die Game-Sounds eine zusammengefasste Binärdatei,
die alle Songs bzw. alle Sounds in einer Datei enthält. Zu beiden Binärdateien wird eine
entsprechende Headerdatei erzeugt, die die Offsets zu den Einzeldateien enthält.
*/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdbool.h>
#include <stdint.h>
#include <dirent.h>

#define SAFE_FREE(x) { if (x != NULL) { free(x); x = NULL; } }

uint8_t *ReadFile(char *pszFilename,uint32_t *puLen);
int CreateHeaderAndBinFile(char * szInputfile, char *szOutputfile, char * szHeaderfile, char * szArrayname);

int main(int argc, char *argv[]) {
    int nErrorCode;
    char szInputfile[64];
    char szOutputfile[64];
    char szHeaderfile[64];
    char szArrayname[64];

    strcpy(szInputfile,"filelist_music.txt");
    strcpy(szOutputfile,"music.bin");
    strcpy(szHeaderfile,"music.h");
    strcpy(szArrayname,"music");

    nErrorCode = CreateHeaderAndBinFile(szInputfile,szOutputfile,szHeaderfile,szArrayname);
    if (nErrorCode == 0) {
        strcpy(szInputfile,"filelist_gamesound.txt");
        strcpy(szOutputfile,"gamesound.bin");
        strcpy(szHeaderfile,"gamesound.h");
        strcpy(szArrayname,"gamesound");
        nErrorCode = CreateHeaderAndBinFile(szInputfile,szOutputfile,szHeaderfile,szArrayname);
    }
    return nErrorCode;
}

/*----------------------------------------------------------------------------
Name:           CreateHeaderAndBinFile
------------------------------------------------------------------------------
Beschreibung: Erzeugt anhand einer Fileliste ein Headerfile und ein zusammengefasstes
              Binärfile aller Einzeldateien.
Parameter
      Eingang: szInputfile, char *, Zeiger auf Dateiname der Fileliste
               szOutputfile, char *, Zeiger auf Dateinamen des zusammengefassten Binärfiles
               szHeaderfile, char *, Zeiger auf Dateinamen des Headerfiles
               szArrayname, char *, Zeiger auf Namen des Arrays im Headerfile
      Ausgang: -
Rückgabewert:  int, 0 = alles OK, sonst Fehler
Seiteneffekte:
------------------------------------------------------------------------------*/
int CreateHeaderAndBinFile(char * szInputfile, char *szOutputfile, char * szHeaderfile, char * szArrayname) {
    char szFilename[512];
    char szHead[1024];
    struct stat Fileinfo;
    char cSign;
    bool bOK;
    size_t uReadCount;
    uint8_t *pData;
    uint32_t uFileLen;
    uint32_t uOffset;
    uint32_t I;
    int32_t uIndex;

    FILE *Readfile = NULL;
    FILE *Writefile = NULL;
    FILE *WriteHeaderfile = NULL;
    bOK =  false;

    if ((szInputfile == NULL) || (szOutputfile == NULL) || (szHeaderfile == NULL) || (szArrayname == NULL)) {
        printf("bad input parameter\r\n");
        return -1;
    }
    if ((strlen(szInputfile) == 0) || (strlen(szOutputfile) == 0) || (strlen(szHeaderfile) == 0) || (strlen(szArrayname) == 0)) {
        printf("empty string(s) found\r\n");
        return -1;
    }

    uIndex = 0;
    if (stat(szInputfile,&Fileinfo) == 0) {
        if (Fileinfo.st_size > 0) {
            WriteHeaderfile = fopen(szHeaderfile,"wb");
            Writefile = fopen(szOutputfile,"wb");
            Readfile = fopen(szInputfile,"rb");
            if ((Readfile != NULL) && (Writefile != NULL) && (WriteHeaderfile != NULL)) {
                strcpy(szHead,"// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT !\r\n\r\n");
                bOK = (fwrite(szHead,1,strlen(szHead),WriteHeaderfile) == strlen(szHead));
                sprintf(szHead,"    uint32_t %s[] = {\r\n",szArrayname);
                bOK = (fwrite(szHead,1,strlen(szHead),WriteHeaderfile) == strlen(szHead));
                memset(szFilename,0,sizeof(szFilename));
                I = 0;
                uReadCount = 0;
                uOffset = 0;
                do {
                    if (fread(&cSign,1,1,Readfile) == 1) {  // 1 Byte aus Datei lesen
                        uReadCount++;
                        if (cSign == 0x0A) {
                            // Zeichen überlesen
                        } else if (cSign == 0x0D) { // Zeilenende ?
                            szFilename[I] = 0;
                            pData = ReadFile(szFilename,&uFileLen);
                            if (pData != NULL) {
                                printf("Filename: %s     FileLen: %u\r\n",szFilename,uFileLen);
                                bOK = (fwrite(pData,1,uFileLen,Writefile) == uFileLen);
                                if (bOK) {
                                    sprintf(szHead,"        0x%08X,0x%08X,     // %04d - %s\r\n",uOffset,uFileLen,uIndex,szFilename);
                                    bOK = (fwrite(szHead,1,strlen(szHead),WriteHeaderfile) == strlen(szHead));
                                    uOffset = uOffset + uFileLen;
                                    uIndex++;
                                } else {
                                    printf("write error\r\n");
                                }
                                SAFE_FREE(pData);
                            } else {
                                printf("can not open file: %s\r\n",szFilename);
                                bOK =  false;
                            }
                            I = 0;  // Für nächsten Filenamen zurück setzen
                            memset(szFilename,0,sizeof(szFilename));
                        } else {
                            szFilename[I] = cSign;
                            I++;
                        }
                    } else {
                        printf("read error\r\n");
                        bOK = false;
                    }
                } while ((uReadCount < Fileinfo.st_size) && bOK);
                if (bOK) {
                    if (I > 0) {    // Letzte Zeile hatte kein 0x0D
                        pData = ReadFile(szFilename,&uFileLen);
                        if (pData != NULL) {
                            printf("Filename: %s     FileLen: %u\r\n",szFilename,uFileLen);
                            bOK = (fwrite(pData,1,uFileLen,Writefile) == uFileLen);
                            if (bOK) {
                                sprintf(szHead,"        0x%08X,0x%08X,     // %04d - %s\r\n",uOffset,uFileLen,uIndex,szFilename);
                                bOK = (fwrite(szHead,1,strlen(szHead),WriteHeaderfile) == strlen(szHead));
                                uOffset = uOffset + uFileLen;
                                uIndex++;
                            } else {
                                printf("write error\r\n");
                            }
                            SAFE_FREE(pData);
                        } else {
                            printf("malloc error\r\n");
                            bOK =  false;
                        }
                    }
                    sprintf(szHead,"        0x%08X,0x%08X      // Endekennung\r\n",0xFFFFFFFF,0xFFFFFFFF);
                    bOK = (fwrite(szHead,1,strlen(szHead),WriteHeaderfile) == strlen(szHead));
                    strcpy(szHead, "        };\r\n");
                    bOK = (fwrite(szHead,1,strlen(szHead),WriteHeaderfile) == strlen(szHead));
                }
            } else {
                printf("can not open file(s)\r\n");
            }
        } else {
            printf("bad filesize: %d\r\n",(int)Fileinfo.st_size);
        }
    } else {
        printf("stat error, file: %s\r\n",szInputfile);
    }
    if (Readfile != NULL) {
        fclose(Readfile);
    }
    if (Writefile != NULL) {
        fclose(Writefile);
    }
    if (WriteHeaderfile != NULL) {
        fclose(WriteHeaderfile);
    }
    if (bOK) {
        return 0;
    } else {
        return -1;
    }
}


/*----------------------------------------------------------------------------
Name:           ReadFile
------------------------------------------------------------------------------
Beschreibung: Liest Daten aus einer Datei und alloziert hierfür Speicher, der
              außerhalb dieser Funktion wieder freigegeben werden muss.
Parameter
      Eingang: pszFilename, char *, Zeiger auf Dateinamen (komplette Pfadangabe)
      Ausgang: puLen, uint32_t *, Anzahl Bytes, die eingelesen bzw. alloziert wurden.
Rückgabewert:  uint8_t *, NULL = Fehler, sonst Zeiger auf allozierten Speicher mit Daten.
Seiteneffekte:
------------------------------------------------------------------------------*/
uint8_t *ReadFile(char *pszFilename,uint32_t *puLen)
{
    uint8_t *pRet = NULL;
    FILE *Readfile = NULL;
    struct stat Fileinfo;

    if ( (pszFilename != NULL) && (puLen != NULL) ) {
        if (stat(pszFilename,&Fileinfo) == 0) {
            if (Fileinfo.st_size > 0) {
                Readfile = fopen(pszFilename,"rb");
                if (Readfile != NULL) {
                    pRet = (uint8_t*)malloc(Fileinfo.st_size);
                    if (pRet != NULL) {
                        if (fread(pRet,1,Fileinfo.st_size,Readfile) == (size_t)Fileinfo.st_size) { // Datei lesen
                            *puLen = Fileinfo.st_size;
                        } else {
                            printf("%s: read error, freeing memory\r\n",__FUNCTION__);
                            SAFE_FREE(pRet);
                        }
                    } else {
                        printf("%s: can not allocate memory for filesize: %ld\r\n",__FUNCTION__,Fileinfo.st_size);
                    }
                } else {
                    printf("%s: can not open file: %s\r\n",__FUNCTION__,pszFilename);
                }
            } else {
                printf("%s: file is empty\r\n",__FUNCTION__);
            }
        } else {
            printf("%s: stat() failed, filename: %s\r\n",__FUNCTION__,pszFilename);
        }
    } else {
        printf("%s: bad parameter\r\n",__FUNCTION__);
    }
    if (Readfile != NULL) {
        fclose(Readfile);
    }
    return pRet;
}
